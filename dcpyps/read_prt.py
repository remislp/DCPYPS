"""
This module contains functions for reading PRT (or txt) files generated by DCPROGS.
"""

import time
import pickle
import numpy as np

import dcpyps
from dcpyps import mechanism


class PrtHJCFIT():
    """Read HJCFIT printout file."""
    def __init__(self, fname, verbose=False):
        self.verbose = verbose
        self.fname = fname
        self.__check_version()

    def __get_line_containing(self, lookup):
        with open(self.fname) as f:
            for num, line in enumerate(f):
                if lookup in line:
                    return num, line
        return None, None
        
    def __check_version(self):
        try:
            num, line = self.__get_line_containing("Program HJCFIT Windows Version (Beta)")
            self.version = 'win'
        except:
            self.version = 'dos'

    def analysis_date(self):
        num, line = self.__get_line_containing('DATE of analysis =')
        return line.split()[-1]

    def __read_conductances(self):
        with open(self.fname,'r') as f:
            conductances = [float(line.split()[-1].strip()) for line in f if "conductance of state" in line]
        return conductances

    def __mec_get_number_of_states(self):
        if self.version == 'win': # and k == 0:
            num, line = self.__get_line_containing("Number of open states =")
            kA = int(line.split()[-1].strip())
            k = len(self.__read_conductances())
            kB = k - kA - 1
            kC = 1
            kD = 0
        else:
            num, line = self.__get_line_containing('No of states in each subset: kA, kB, kC, kD =')
            kA = int(line.split()[-4].strip())
            kB = int(line.split()[-3].strip())
            kC = int(line.split()[-2].strip())
            kD = int(line.split()[-1].strip())
            k = kA + kB + kC + kD

        print ("Number of states: kA, kB, kC, kD = {0:d}, {1:d}, {2:d}, {3:d}".format(kA, kB, kC, kD))
        return k, kA, kB, kC, kD

    def read_mec(self):

        k, kA, kB, kC, kD = self.__mec_get_number_of_states()
        conductance = self.__read_conductances()

        ncyc, nsc, im2, jm2, mr = 0, [], [], [], []
        states, ligbound = [], []
        tres, tcrit, CHS = [], [], []
        rates, constrained = [], []


        



                

def load_mec_from_prt(filename, verbose=False):    
    f = open(filename, 'r')
    linenum = 0
    
    
    ncyc, nsc, im2, jm2, mr = 0, [], [], [], []
    states, conductance, ligbound = [], [], []
    tres, tcrit, CHS = [], [], []
    rates, constrained = [], []
    k, kA, kB, kC, kD = 0, 0, 0, 0, 0

    f.readline()
    line = f.readline()
    if "Program HJCFIT Windows Version (Beta)" in line:
        version = 'win'
    else:
        version = 'dos'
    if verbose: print ('version=', version)

    while True:
        try:
            line = f.readline()
            #print 'line:', line
            if line == '':
                break
            line = line.strip("\r\n")
            linenum += 1
        except EOFError:
            print('Mecanism loading from PRT (or TXT) file finished.')
            
        if "HJCFIT: Fit of model to open-shut times with missed events" in line:
            if verbose: print ('This is possibly HJCFIT printout file.')
            
        if "No of states in each subset: kA, kB, kC, kD =" in line:
            kA = int(line.split()[-4].strip())
            kB = int(line.split()[-3].strip())
            kC = int(line.split()[-2].strip())
            kD = int(line.split()[-1].strip())
            k = kA + kB + kC + kD
            if verbose: print ("Number of states: kA, kB, kC, kD = {0:d}, {1:d}, {2:d}, {3:d}".
                format(kA, kB, kC, kD))

        if version == 'win' and "Number of open states =" in line and k == 0:
            kA = int(line.split()[-1].strip())
            if verbose:
                print("Number of open states = ", kA)
            line = f.readline()
            while (line != "\n") and ("conductance of state" in line):
                conductance.append(float(line.split()[-1].strip()))
                line = f.readline()
            k = len(conductance)
            kB = k - kA - 1
            kC = 1
            kD = 0
            if verbose: print ("Number of states: kA, kB, kC, kD = {0:d}, {1:d}, {2:d}, {3:d}".
                format(kA, kB, kC, kD))
            
        if "Number of ligands =" in line:
            nlig = int(line.split()[-1].strip())
            if verbose: print ("Number of ligands = {0:d}".format(nlig))
            f.readline() #'Concentration-dependent elements:'
            f.readline() #'  i   j     ligand #   Ligand name'
            line = f.readline()
            im, jm, lig = [], [], []
            while line != "\n":
                temp = line.split()
                im.append(int(temp[0]))
                jm.append(int(temp[1]))
                lig.append(temp[-1])
                line = f.readline()
            if verbose: print ("im=", im)
            if verbose: print ("jm=", jm)
            if verbose: print ("lig=", lig)
                
        
        if (version == 'dos') and ("Cycle #" in line) and (int(line[-1]) > ncyc):
            c1, c2 = [], []
            ncyc += 1
            line = f.readline()
            temp = line.split()
            c1.append(int(temp[1].strip(',')))
            c2.append(int(temp[2].strip(')')))
            mr.append([int(temp[1].strip(',')), int(temp[2].strip(')'))])
            line = f.readline()
            temp = line.split()
            while temp:
                c1.append(int(temp.pop(0).strip('-')))
                c2.append(int(temp.pop(0)))
            nsc.append(len(c1))
            im2.append(c1)
            jm2.append(c2)
            if verbose: print ("Cycle # ", ncyc)
            if verbose: print (nsc)
            if verbose: print (im2, jm2)

        if (version == 'win') and ("Microscopic reversibility" in line):
            #print('version=', version)
            line = f.readline()
            while "cycle=" in line:
                c1, c2 = [], []
                ncyc += 1
                temp = line.strip(';').split()
                nsc.append(int(temp[5].strip(',')))
                temp = temp[7:]
                for item in temp:
                    c1.append(int(item.strip(';')))
                im2.append(c1)
                line = f.readline()

        if (version == 'win') and ("by microscopic reversibility" in line):
            if len(mr) < ncyc:
                temp = []
                temp.append(int(line[3:5].strip()))
                temp.append(int(line[6:8].strip()))
                mr.append(temp)
            
#        if "state #    state name" in line: # in 'dos'
#            line = f.readline()
#            while line != "\n":
#                temp = line.split()
#                states.append(temp[1])
#                line = f.readline()
#            if len(states) == k:
#                if verbose: print states
#            else:
#                print "Warning: number of states does not correspond."
                
        if "Number of ligands bound" in line:
            line = f.readline()
            line = f.readline()     
            while len(states) < k:
                temp = line.split()
                if len(temp) == 3:
                    states.append(temp[1])
                    ligbound.append(int(temp[2]))
                line = f.readline()
            if verbose: print ('states: ', states)
            if verbose: print ('ligandsbound=', ligbound)
                
        if "Resolution for HJC calculations" in line:
            line = f.readline()
            while line != "\n":
                temp = line.split()
                if len(temp) == 4:
                    tres.append(float(temp[2]) * 1e-6)
                line = f.readline()
            if verbose: print ('resolution: ', tres)
            
        if "The following parameters are constrained:" in line:
            line = f.readline()
            while '-----' not in line:
                cnstr = []
                temp = line.split()
                r1 = int(temp[1]) - 1
                line = f.readline()
                temp = line.split()
                fac = float(temp[0])
                op = temp[1]
                r2 = int(temp[3]) - 1
                cnstr.append(r1)
                cnstr.append(op)
                cnstr.append(fac)
                cnstr.append(r2)
                line = f.readline()
                constrained.append(cnstr)
#            print constrained
            
        if (version == 'dos') and ("initial        final" in line):
            line = f.readline()
            while line != "\n":
                rate = []
                if 'q(' in line:
                    rate.append(int(line[8:10].strip()))
                    rate.append(int(line[11:13].strip()))
                    rate.append(line[18:29].strip())
                    rate.append(float(line[42:55].strip()))
                    if len(line) > 55:
                        rate.append(line[55:].strip().strip('(').strip(')'))
                rates.append(rate)
                line = f.readline()
            if constrained:
                for item in constrained:
                    if len(rates[item[0]]) > 4: # and rates[item[0, 4]] == 'constrained':
                        rates[item[0]].append(item[1])
                        rates[item[0]].append(item[2])
                        rates[item[0]].append(item[3])
            if verbose: print (rates)
            
        if (version == 'win') and ("initial        final" in line):
            while len(rates) < numrates:
                rate = []
                line = f.readline()
                while line != "\n":
                    rate.append(int(line[8:10].strip()))
                    rate.append(int(line[11:13].strip()))
                    rate.append(line[18:29].strip())
                    rate.append(float(line[42:55].strip()))
                    rates.append(rate)
                    line = f.readline()
                    if line != "\n":
                        rates[-1].append(line.strip().strip('(').strip(')'))
                        line = f.readline()
            
        if 'Total number of rates' in line:
            numrates = int(line.split()[-1])
            numfixed = int(f.readline().split()[-1])
            numconstr = int(f.readline().split()[-1])
            nummr = int(f.readline().split()[-1])
            numec50 = int(f.readline().split()[-1])
            numfree = int(f.readline().split()[-1])
            if verbose: print ('\nTotal number of rates = {0:d}'.format(numrates) +
                '\nNumber that are fixed       = {0:d}'.format(numfixed) +
                '\nNumber that are constrained = {0:d}'.format(numconstr) +
                '\nNumber set by micro rev     = {0:d}'.format(nummr) +
                '\nNumber set by fixed EC50    = {0:d}'.format(numec50) +
                '\nNumber of free rates to be estimated = {0:d}'.format(numfree))

    if verbose: print ('file contains {0:d} lines'.format(linenum))
    f.close()
    
    StateList = []
    j = 0
    for i in range(kA):
        StateList.append(dcpyps.State('A', states[j], 50))
        j += 1
    for i in range(kB):
        StateList.append(dcpyps.State('B', states[j], 0))
        j += 1
    for i in range(kC):
        StateList.append(dcpyps.State('C', states[j], 0))
        j += 1
    for i in range(kD):
        StateList.append(dcpyps.State('D', states[j], 0))
        j += 1
        
    RateList = []
    for i in range(numrates):
        bound = None
        mrc = False
        is_constr = False
        constr_func = None
        constr_args = None
        for j in range(len(im)):
            if im[j] == rates[i][0] and jm[j] == rates[i][1]:
                bound = 'c'
        for j in range(ncyc):
            if mr[j][0] == rates[i][0] and mr[j][0] == rates[i][1]:
                mrc = True
        if len(rates[i]) > 5 and rates[i][4] == 'constrained':
            is_constr = True
            if rates[i][5] == 'times':
                constr_func = mechanism.constrain_rate_multiple
                constr_args = [rates[i][7], rates[i][6]]
        
        rate = rates[i][3]
        RateList.append(dcpyps.Rate(rate, StateList[rates[i][0]-1],
            StateList[rates[i][1]-1], name=rates[i][2], eff=bound, mr=mrc,
            is_constrained=is_constr, constrain_func=constr_func, constrain_args=constr_args))
            
    CycleList = []
    for i in range(ncyc):
#        mrconstrained = False
        CycleStates = []
        for j in range(nsc[i]):
            CycleStates.append(states[im2[i][j]-1])
        CycleList.append(dcpyps.Cycle(CycleStates))

    return dcpyps.Mechanism(RateList, CycleList)

#def set_load_from_prt(filename, verbose=False):    
#    f = open(filename, 'r')
#    linenum = 0
#    
#    scnfiles = []
#    conc, tres, tcrit, chsvec = [], [], [], []
#    
#    f.readline()
#    line = f.readline()
#    if "Program HJCFIT Windows Version (Beta)" in line:
#        version = 'win'
#    else:
#        version = 'dos'
#    if verbose: print 'version=', version
#
#    while True:
#        try:
#            line = f.readline()
#            #print 'line:', line
#            if line == '':
#                break
#            line = line.strip("\r\n")
#            linenum += 1
#        except EOFError:
#            print('Data set loading from PRT (or TXT) file finished.')
#            
#    return scnfiles, conc, tres, tcrit, chsvec

def read_covmat_from_prt(filename, verbose=False):
    linenum = 0
    do_read = False
    do_read_rates = False
    not_finished = True
    n = []
    rate_lines = []
    f = open(fname)
    while not_finished:
 
        line = f.readline()
        if do_read:
            if line.find("Determinant of INFO matrix") != -1:
                do_read = False
                not_finished = False
                do_read_rates = False
            if line.find("j=") != -1:
                n += map(int, line.split()[1:])
            if line.find("i =") != -1:
                do_read_rates = True
            if line.find("Covariance matrix=") != -1: 
                print(linenum, line.rstrip('\n')) 
                do_read = True
            if do_read_rates and line != "\n":
                rate_lines.append(line.rstrip('\n').replace("-", " -"))
        if line.find("Covariance matrix=") != -1: 
            do_read = True
        linenum += 1
    f.close()    
    
    k = len(rate_lines) // len(n)
    r = [ x+y for x,y in zip(rate_lines[1::k], rate_lines[2::k])]
    covmat = np.zeros((len(n), len(n)))
    for i, each in enumerate(r):
        covmat[i] = np.fromstring(each, dtype=float, sep=' ')

    return covmat

def pickle_stuff(ob, outfname):
    outfile = open(filename,'wb')
    pickle.dump(ob,outfile)
    outfile.close()
############


fname = "./samples/etc/tr71t06X.txt"
#covmat = read_covmat_from_prt(fname, verbose=False)
#print(covmat)
mec = load_mec_from_prt(fname)
#print(mec)

filename = 'covmat6X.pickle'
#pickle_stuff(covmat, filename)
filename = 'mec6X.pickle'
#pickle_stuff(mec, filename)

prt = PrtHJCFIT(fname)
print('HJCFIT version: ', prt.version)
print('DATE of analysis: ', prt.analysis_date())
prt.read_mec()





    

    